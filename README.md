# Xorlib

Provide some useful annotations and methods for Minecraft Modding.

Only support neoforge for now.

This is a complie-only library. So users don't need to add dependencies to their mods.

## Getting start

This library had released on Maven Central.

```build.gradle
dependencies {
    compileOnly(annotationProcessor("com.xkball:XorLib:0.1.1:all"))
}
```

Add environment variable `XORLIB.DEBUG=TRUE` to show more information when comilation.

## Contents

### @ModMeta

Some metadata of a mod and some configuration of XorLib annotation processor.
The annotation should apply to EVERY class with `net.neoforged.fml.common.Mod`. Any missing match of these two annotations will cause compilation exception.

Xorlib get your modid from through this annotation.

Example:

```java
@ModMeta(useLanguages = {"en_us","zh_cn"})
```

### @NetworkPacket

Before compilation:

```java
@NetworkPacket(type = NetworkPacket.Type.PLAY_SERVER_TO_CLIENT)
public record ANetworkPack(ItemStack forExample){
    
    @NetworkPacket.Codec
    public static final StreamCodec<RegistryFriendlyByteBuf, ANetworkPack> STREAM_CODEC = StreamCodec.composite(
            ItemStack.STREAM_CODEC,
            ANetworkPack::forExample,
            ANetworkPack::new
    );
    
    @NetworkPacket.Handler
    public void handle(IPayloadContext context) {
        context.enqueueWork(() -> {
            // handler code here
        });
    }
    
}
```

After compilation:

```java
@EventBusSubscriber(
    modid = "your mod id",
    bus = Bus.MOD
)
@NetworkPacket(type = Type.PLAY_SERVER_TO_CLIENT)
public record ANetworkPack(ItemStack stack) implements CustomPacketPayload {

    @Codec
    public static final StreamCodec<RegistryFriendlyByteBuf, ANetworkPack> STREAM_CODEC;
    
    public static final CustomPacketPayload.Type TYPE;

    @Handler
    public void handle(IPayloadContext context) {
        context.enqueueWork(() -> {
         	// handler code here
        });
    }

    public CustomPacketPayload.Type type() {
        return TYPE;
    }

    @SubscribeEvent
    public static void register(RegisterPayloadHandlersEvent event_) {
        PayloadRegistrar register = event_.registrar("your mod id");
        register.playToClient(TYPE, STREAM_CODEC, ANetWorkPack::handle);
    }

    static {
        STREAM_CODEC = StreamCodec.composite(ItemStack.STREAM_CODEC, ANetworkPack::stack,ANetworkPack::new);
        TYPE = new CustomPacketPayload.Type(ResourceLocation.fromNamespaceAndPath("your mod id", "a_network_pack"));
    }
}

```

### @DataGenProvider

Before compilation:

```java
@DataGenProvider
public class ModItemModelProvider extends ModelProvider {
    
    public ModItemModelProvider(PackOutput output) {
        super(output, MODID);
    }
    
    @Override
    protected void registerModels(BlockModelGenerators blockModels, ItemModelGenerators itemModels) {
        //...
    }
}
```

After compilation:

```java
@EventBusSubscriber(
    modid = "your mod id",
    bus = Bus.MOD
)
@DataGenProvider
public class ModItemModelProvider extends ModelProvider {
    public ModItemModelProvider(PackOutput output) {
        super(output, "your mod id");
    }

    protected void registerModels(BlockModelGenerators blockModels, ItemModelGenerators itemModels) {
        //...
    }

    @SubscribeEvent
    public static void xorLibGenerate$onClient(GatherDataEvent.Client event_) {
        ModItemModelProvider modItemModelProvider = new ModItemModelProvider(event_.getGenerator().getPackOutput());
        event_.addProvider(modItemModelProvider);
        //Following codes are generated by another xorlib function.
        YourModMainClass.XorLibGenerate.EN_USProvider xorLibGenerate$EN_USProvider = new LetMeSeeSee.XorLibGenerate.EN_USProvider(event_.getGenerator().getPackOutput());
        event_.addProvider(xorLibGenerate$EN_USProvider);
        YourModMainClass.XorLibGenerate.ZH_CNProvider xorLibGenerate$ZH_CNProvider = new LetMeSeeSee.XorLibGenerate.ZH_CNProvider(event_.getGenerator().getPackOutput());
        event_.addProvider(xorLibGenerate$ZH_CNProvider);
    }
}
```

The following list shows the type of parameters that can be filled in automatically. 

1.21.1 NeoForge:

- `net.neoforged.fml.ModContainer`
- `net.minecraft.data.DataGenerator`
- `net.neoforged.neoforge.common.data.ExistingFileHelper`
- `java.util.Collection<java.nio.file.Path>` (inputs)
- `java.util.concurrent.CompletableFuture<net.minecraft.core.HolderLookup.Provider>`
- `net.minecraft.data.PackOutput`
- `java.lang.String` (param name must be "modid" ignored case.)

1.21.4 NeoForge have one more parameter.

- `net.minecraft.server.packs.resources.ResourceManager`



### @SubscribeEventEnhanced

Use like `@SubscribeEvent` but only support static methods but don't need `@EventBusSubscriber`. The annotation processor will automatcially seclect right EventBus. 

This annotation has one more field than `@SubscribeEvent` which is `String[] requireModLoaded()`.Keep empty and processor will ignore it. If entered one or more modids, all those mods must all be loaded for the event to be subscribed.



### Embedded localization for translatable `net.minecraft.network.chat.Component`

Using this feature means you cannot write any method named **tr** and **trWithKey**.

Disable this feature through `@ModMeta(disabledFratures = {Featrue.EMBEDDED_L10N_COMPONENT})`

Use static method `XL.tr(String... i18n)` anywhere, and xorlib will replace it to `Component.translatable("generated key")` then generate an `LanguageProvider` to datagen all those localizations. The language order is declared in `@ModMeta{useLanguages=[...]}`.

Similarly, use `XL.trWithKey(String key, String ... i18n)` have identical function but use your declared key.

### `XL.staticLazy`

Before compilation:

```java
public void aMethod(){
    System.out.println(XL.staticLazy("1"));
}
```

After compilation:

```java
private static final net.neoforged.neoforge.common.util.Lazy<String> XORLIB_GENERATED_LAZY_0 = Lazy.of("1");

public void aMethod(){
    System.out.println(XL.staticLazy(XORLIB_GENERATED_LAZY_0.get()));
}
```

